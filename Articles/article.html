<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="./article.css">
    <link rel="stylesheet" href="../libraries/prism.css">
    <title>Write article</title>
</head>

<body>
    <div id="main_container">
        <div id="suggestions_box">

        </div>
        <div id="content_box">
            <!-- <h1>{{title}}</h1> -->
            <h1>Binary Search in Python</h1>
            <div>
                Binary search is a sorting algorithm that helps to locate elements in a sorted array.
                Unlike linear search, Binary search does not work by comparing the key with every element of the array.
                At every step, it divides the array into two parts, discards one part, and then searches for the key
                in the other part. Hence, it is faster than linear search.
            </div>
            <ul style="list-style-position: inside;">
                <h3>Jump to specific sections</h3>
                <li>
                    <a href="#algo">Algorithm</a>
                </li>
                <li>
                    <a href="#iterative">Iterative Approach</a>
                </li>
                <li>
                    <a href="#recursive">Recursive Approach</a>
                </li>
                <li>
                    <a href="#points">Advantages and Disadvantages</a>
                </li>
            </ul>
            <h3 id="algo">Algorithm</h3>
            <div>
                <ol>
                    <li>
                        Initially, we have a list of size N. In the first iteration, we will compare the
                        key with the middle element i.e. the element at index (N/2). If arr[mid] = = key,
                        we are done.
                    </li>
                    <li>
                        Otherwise, If arr[mid] &lt;= key, this means that the key is greater than the middle element.
                        Since the list is sorted, we know that if the key is present, then it would be found from index
                        mid+1 to N-1. For e.g. if the list is [1,2,3,5] and key=3, then arr[mid]=1 which is smaller than
                        3,
                        so we know that if 3 is present, it would come after 2 in the list. Hence, we would search for
                        the key
                        between index mid+1 to N-1.
                    </li>
                    <li>Else if arr[mid] &gt;= key, this means that the key is smaller than the middle element.
                        Hence, we would search for the key between index 0 to mid-1.
                    </li>
                    <li>We will repeat the same procedure in that part of the list (i.e from 0 to mid-1 or mid+1 to N-1)
                        by finding the middle element
                        and then comparing with the key until the key is found or the list gets finished.</li>
                </ol>
            </div>
            <img src="binary_search.jpg" alt="">
            <h3 id="iterative">Iterative Approach</h3>
            <div>
            </div>
            <pre class="language-python"><code>
def binary_search(arr,key):
    low=0
    high=len(arr)-1

    while low &lt;= high:
        mid=(high-low)//2
        if key==arr[mid]
            found_at=i
        if arr[i]>mid:
            low=mid+1
        else:
            high=mid-1

    # if we reach the end of the list and the key is not found, we return -1.
    return -1

arr=[1,2,3,4,5,6]
key=int(input("Enter key to search: "))

found_at=binary_search(arr,key)

if found_at!=-1:
print("Key found at index ",i)
else:
print("Key not found")
</code></pre>
            <div>Output</div>
            <pre>
Enter key to search: 3
Key found at index 2
</pre>
            <div><b>Time Complexity</b> : O(log n) where n is the size of the list.</div>
            <div><b>Explanation</b> : Suppose we have a list of size n. At first, we will compare the key
                with the element at (n/2)<sup>th</sup>index. If it is greater than the key, then will compare
                the key with the (n/2-0)/2<sup>th</sup> element and if the middle element is smaller, then we will
                compare the key with the (n-n/2)/2<sup>th</sup> element and so on.
                <br>
                Hence, the key would be found in a maximum of log n comparisons i.e. if there are 16 elements in the
                list,
                then the key would be found in at most 4 comparisons. So, the time complexity of binary search will be
                O(log n).
            </div>
            <div><b>Space Complexity</b> : O(1) no additional space used.</div>
            <h3 id="recursive">Recursive Approach</h3>
            <div>

            </div>
            <pre class="language-python"><code>
def binary_search(arr,key,low,high):
    if low&gt;high:
        return -1
    mid=(high-low)//2
    if key==arr[mid]:
        return i
    elif key>arr[mid]:
        return binary_search(arr,key,mid+1,high)
    else:
        return binary_search(arr,key,low,mid-1)

arr=[1,3,2,5,7]
key=int(input("Enter key to search: "))

found_at=binary_search(arr,key,0,len(arr)-1)

if found_at!=-1:
print("Key found at index ",i)
else:
print("Key not found")
</code></pre>
            <div>Output</div>
            <pre>
Enter key to search: 2
Key found at index 1
</pre>
            <div><b>Time Complexity</b> : O(log n) same as the iterative approach.</div>
            <div><b>Space Complexity</b> : O(n) for recursion stack.</div>
            <h3>Advantages and Disadvantages</h3>
            <div><b>Advantages</b> :
                <ol>
                    <li>It is faster than linear search. Takes only O(log n) time.</li>
                </ol>
            </div>
            <div><b>Disadvantages</b> :
                <ol>
                    <li>It works for sorted arrays only. So, if the array is not sorted,
                        then to sort it we need to take O(n log n) extra time which will make it worse
                        than linear search.
                    </li>
                </ol>
            </div>


        </div>
    </div>

    <hr>
    <div id="guide">
        <h3>Tags that can be used</h3>
        <ul>
            <li>h1, h2, h3 -> for headings.</li>
            <li>div -> for each paragraph.</li>
            <li>span -> for bold</li>
            <li>img -> for image</li>
            <li>a -> for links</li>
            <li>ol and ul -> for lists</li>
            <li>li -> for points</li>
            <li>pre -> for content which should be presented as specified. Ex - long links, terminal commans, git
                commands</li>
            <li>pre with code -> for inserting code in article. Consider below example:</li>
            <pre>

    &lt;pre class="language-python"&gt;&lt;code&gt;
        print("Hello Rapid Coders")
    &lt;/code&gt;&lt;/pre&gt;
            </pre>
        </ul>
    </div>

    <script src="../libraries/prism.js"></script>
</body>

</html>