<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="styles.css">
    <title>Color Wheel Picker</title>
</head>

<body>
    <div class="container">
        <div id="inputElements">
            <div class="color-wheel-container">
                <canvas id="colorWheel" width="300" height="300"></canvas>
                <div id="pointer"></div>
            </div>
            <div class="opacity-slider-container">
                <input type="range" id="opacitySlider" min="0" max="1" step="0.01" value="1">
            </div>
        </div>

        <div class="output-container">
            <div class="color-display" id="colorDisplay"></div>
            <div class="output">
                <div>
                    <span>RGB:</span>
                    <span id="rgbOutput">None</span>
                    <button class="copy-btn" onclick="copyText('rgbOutput')">Copy</button>
                </div>
                <div>
                    <span>HEX:</span>
                    <span id="hexOutput">None</span>
                    <button class="copy-btn" onclick="copyText('hexOutput')">Copy</button>
                </div>
                <div>
                    <span>HSL:</span>
                    <span id="hslOutput">None</span>
                    <button class="copy-btn" onclick="copyText('hslOutput')">Copy</button>
                </div>
            </div>
        </div>
    </div>
    <script>
        const canvas = document.getElementById('colorWheel');
        const ctx = canvas.getContext('2d', { willReadFrequently: true });
        const pointer = document.getElementById('pointer');
        const rgbOutput = document.getElementById('rgbOutput');
        const hexOutput = document.getElementById('hexOutput');
        const hslOutput = document.getElementById('hslOutput');
        const colorDisplay = document.getElementById('colorDisplay');
        const opacitySlider = document.getElementById('opacitySlider');

        const width = canvas.width;
        const height = canvas.height;
        const radius = Math.min(width, height) / 2;
        const centerX = width / 2;
        const centerY = height / 2;

        let isDragging = false;

        // Helper Functions
        function hslToRgb(h, s, l) {
            s /= 100;
            l /= 100;
            const c = (1 - Math.abs(2 * l - 1)) * s;
            const x = c * (1 - Math.abs((h / 60) % 2 - 1));
            const m = l - c / 2;

            const [r, g, b] =
                h < 60 ? [c, x, 0] :
                    h < 120 ? [x, c, 0] :
                        h < 180 ? [0, c, x] :
                            h < 240 ? [0, x, c] :
                                h < 300 ? [x, 0, c] : [c, 0, x];

            return [Math.round((r + m) * 255), Math.round((g + m) * 255), Math.round((b + m) * 255)];
        }

        function rgbToHex(r, g, b) {
            return `#${((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1).toUpperCase()}`;
        }

        function rgbaToHex(r, g, b, a) {
            const alpha = Math.round(a * 255).toString(16).padStart(2, '0').toUpperCase();
            return `${rgbToHex(r, g, b)}${alpha}`;
        }

        function rgbToHsl(r, g, b) {
            r /= 255; g /= 255; b /= 255;
            const max = Math.max(r, g, b), min = Math.min(r, g, b);
            const delta = max - min;

            const l = (max + min) / 2;
            const s = delta === 0 ? 0 : delta / (1 - Math.abs(2 * l - 1));
            const h =
                delta === 0 ? 0 :
                    max === r ? ((g - b) / delta + (g < b ? 6 : 0)) * 60 :
                        max === g ? ((b - r) / delta + 2) * 60 :
                            ((r - g) / delta + 4) * 60;

            return [Math.round(h), Math.round(s * 100), Math.round(l * 100)];
        }

        function updateOutput(r, g, b, opacity) {
            const rgb = opacity === 1 ? `rgb(${r}, ${g}, ${b})` : `rgba(${r}, ${g}, ${b}, ${opacity})`;
            const hex = opacity === 1 ? rgbToHex(r, g, b) : rgbaToHex(r, g, b, opacity);
            const [h, s, l] = rgbToHsl(r, g, b);
            const hsl = opacity === 1 ? `hsl(${h}, ${s}%, ${l}%)` : `hsla(${h}, ${s}%, ${l}%, ${opacity})`;

            rgbOutput.textContent = rgb;
            hexOutput.textContent = hex;
            hslOutput.textContent = hsl;
            colorDisplay.style.backgroundColor = rgb;
        }

        function getPointerColor(x, y) {
            const dx = x - centerX;
            const dy = y - centerY;
            const distance = Math.sqrt(dx * dx + dy * dy);
            if (distance > radius) return null;

            const pixel = ctx.getImageData(x, y, 1, 1).data;
            return [pixel[0], pixel[1], pixel[2]];
        }

        function updatePointerAndColor(x, y) {
            const rect = canvas.getBoundingClientRect();
            const canvasX = x - rect.left;
            const canvasY = y - rect.top;
            const color = getPointerColor(canvasX, canvasY);
            if (color) {
                pointer.style.left = `${canvasX}px`;
                pointer.style.top = `${canvasY}px`;
                const [r, g, b] = color;
                updateOutput(r, g, b, parseFloat(opacitySlider.value));
            }
        }

        // Draw the color wheel
        function drawColorWheel() {
            const imageData = ctx.createImageData(width, height);
            const data = imageData.data;

            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    const dx = x - centerX;
                    const dy = y - centerY;
                    const distance = Math.sqrt(dx * dx + dy * dy);

                    if (distance <= radius) {
                        const angle = Math.atan2(dy, dx) + Math.PI;
                        const hue = (angle / (2 * Math.PI)) * 360;
                        const saturation = (distance / radius) * 100;
                        const [r, g, b] = hslToRgb(hue, saturation, 50);

                        const index = (y * width + x) * 4;
                        data[index] = r;
                        data[index + 1] = g;
                        data[index + 2] = b;
                        data[index + 3] = 255; // Alpha
                    }
                }
            }
            ctx.putImageData(imageData, 0, 0);

            // move pointer to center 
            pointer.style.left = `${centerX}px`;
            pointer.style.top = `${centerY}px`;
            updatePointerAndColor(centerX, centerY);
        }

        // Copy text to clipboard
        function copyText(elementId) {
            const text = document.getElementById(elementId).textContent;
            navigator.clipboard.writeText(text).then(() => {
                alert(`${text} copied to clipboard!`);
            });
        }

        //  event listeners
        canvas.addEventListener('mousedown', () => isDragging = true);
        window.addEventListener('mouseup', () => isDragging = false);
        canvas.addEventListener('mousemove', (e) => {
            if (isDragging) {
                updatePointerAndColor(e.clientX, e.clientY);
            }
        });
        canvas.addEventListener('click', e => {
            updatePointerAndColor(e.clientX, e.clientY);
        })

        opacitySlider.addEventListener('input', () => {
            const currentOpacity = parseFloat(opacitySlider.value);
            const match = rgbOutput.textContent.match(/rgba?\((\d+),\s*(\d+),\s*(\d+)(?:,\s*([\d.]+))?\)/);
            if (match) {
                const r = parseInt(match[1]);
                const g = parseInt(match[2]);
                const b = parseInt(match[3]);
                updateOutput(r, g, b, currentOpacity);
            }
        });

        // Initial Setup
        window.addEventListener('DOMContentLoaded', () => {
            drawColorWheel();
            updateOutput(255, 255, 255, 1); // Default white color  
        });

    </script>
</body>

</html>